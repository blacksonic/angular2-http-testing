{"version":3,"file":"backend-expectation.js","sourceRoot":"","sources":["backend-expectation.ts"],"names":[],"mappings":";AACA,sCAAkF;AASlF,uBAAuB,IAAqB;IAC1C,MAAM,CAAC,OAAO,IAAI,KAAK,QAAQ;UAC3B,IAAI;UACJ,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;AACpC,CAAC;AAED;IAKE,4BAAoB,OAAkC;QAAlC,YAAO,GAAP,OAAO,CAA2B;QAJ9C,eAAU,GAAG,KAAK,CAAC;IAI8B,CAAC;IAE1D,0CAAa,GAAb;QACE,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC;IACzB,CAAC;IAED,oCAAO,GAAP,UAAQ,IAAqB,EAAE,MAAoB,EAAE,OAA4C;QAAlE,uBAAA,EAAA,YAAoB;QACjD,IAAI,CAAC,eAAe,GAAG,IAAI,sBAAe,CAAC,EAAE,MAAM,QAAA,EAAE,IAAI,MAAA,EAAE,OAAO,EAAE,IAAI,cAAO,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;IAC9F,CAAC;IAED,6CAAgB,GAAhB,UAAiB,KAAqB;QACpC,IAAI,CAAC,aAAa,GAAG,OAAO,KAAK,KAAK,QAAQ,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;IAC5E,CAAC;IAED,mCAAM,GAAN,UAAO,UAA0B;QAAjC,iBAmBC;QAlBC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QAEvB,MAAM,CAAC,UAAU,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,EAAE,uBAAuB,CAAC,CAAC;QAClF,MAAM,CAAC,UAAU,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,0BAA0B,CAAC,CAAC;QAE3F,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;YACtB,MAAM,CAAC,UAAU,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,wBAAwB,CAAC,CAAC;QAC3G,CAAC;QAED,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,UAAC,MAAM,EAAE,IAAI;YACxC,MAAM,CAAC,UAAU,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,KAAI,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,0BAA0B,CAAC,CAAC;QACnH,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,CAAC;YACxB,UAAU,CAAC,WAAW,CAAC,IAAI,eAAQ,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,CAAC;QAC7D,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,UAAU,CAAC,SAAS,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QAC3C,CAAC;IACH,CAAC;IACH,yBAAC;AAAD,CAAC,AAvCD,IAuCC;AAvCY,gDAAkB","sourcesContent":["import { MockConnection } from '@angular/http/testing';\nimport { Response, ResponseOptions, RequestMethod, Headers } from '@angular/http';\n\nexport interface BackendExpectationOptions {\n  url: string;\n  method: RequestMethod;\n  headers: Headers;\n  body?: string | Object;\n}\n\nfunction stringifyBody(body: string | Object) {\n  return typeof body === 'string'\n    ? body\n    : JSON.stringify(body, null, 2);\n}\n\nexport class BackendExpectation {\n  private isVerified = false;\n  private responseOptions: ResponseOptions;\n  private responseError?: Error;\n\n  constructor(private options: BackendExpectationOptions) {}\n\n  getIsVerified() {\n    return this.isVerified;\n  }\n\n  respond(body: string | Object, status: number = 200, headers?: Headers | { [name: string]: any; }) {\n    this.responseOptions = new ResponseOptions({ status, body, headers: new Headers(headers) });\n  }\n\n  respondWithError(error: string | Error) {\n    this.responseError = typeof error === 'string' ? new Error(error) : error;\n  }\n\n  verify(connection: MockConnection) {\n    this.isVerified = true;\n\n    expect(connection.request.url).toEqual(this.options.url, 'Request url mismatch.');\n    expect(connection.request.method).toEqual(this.options.method, 'Request method mismatch.');\n\n    if (this.options.body) {\n      expect(connection.request.getBody()).toEqual(stringifyBody(this.options.body), 'Request body mismatch.');\n    }\n\n    this.options.headers.forEach((values, name) => {\n      expect(connection.request.headers.get(name)).toEqual(this.options.headers.get(name), 'Request header mismatch.');\n    });\n\n    if (!this.responseError) {\n      connection.mockRespond(new Response(this.responseOptions));\n    } else {\n      connection.mockError(this.responseError);\n    }\n  }\n}\n"]}